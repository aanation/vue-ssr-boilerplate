# SSR VueJS 42px Template

* Webpack
* Babel
* VueJS
* Vuex
* Vue-router
* Express (как роутер для рендер-сервера)
* scss/sass
* postcss (autoprefixer)
* dev-server (HMR)
* uglifyJS

VueJS шаблон для разработки и cборки приложений с серверным рендерингом или без него (обычное html/css/js SPA). 
Базируется на официальной документации VueJs по сборке SSR-фронтенда (https://ssr.vuejs.org/) и официальном примере сборки от Эвана: https://github.com/vuejs/vue-hackernews-2.0, коя была значительно расширена и модифицирована исходя из задач реального проекта. 


## Использование

**npm run dev** - запускает dev-server с серверным рендерингом

**npm run build** - билдит серверный бандл и клиентский манифест для серверного рендеринга

**npm run build-server** - билдит серверный бандл для SSR

**npm run build-client** - билдит клиентское приложение, формирует манифест SSR 

**npm run render-server** - запускает продакшн рендер-сервер на базе express. 

**npm run dev-spa** - запускает dev-server с традиционным SPA (без SSR)

**npm run build-spa** - билдит традиционное spa (без SSR)

**npm run tests** - запуск юнит-тестов Karms + mocha 

## Конфиг 

Основной конфиг фронтенда находится в /config.js. 
Там можно (и нужно) настроить сервер и порт на который будут проксироваться запросы к api (сервер с апи). Там же настраивается каталог в который будет билдится собранный фронтенд. 
Конфиг в достаточной степени очевиден. 

## Переменные окружения 

* **NODE_ENV** - при запуске server.js определяет окружение. В production окружении поднимает экспресс сервер с SSR-рендерингом приложения, предварительно собранного в /build. В development-окружении поднимает дев-сервер с HMR. При подключении через npm server.js запускается как production вне зависимости от реальной переменной окружения 

* **PORT** - порт на котором запускается рендер-сервер (по умолчанию 8080) в девелопмент или продакшен окружении 

* **BACKEND_PORT** - порт, на который будут отправляться запросы с рендер-сервера для получения данных необходимых для первичного рендеринга HTML. В отсутсвие данной переменной в качестве этого порта используется переменная PORT, а если не задана и она, то 8080. При включенном проксировании на уровне рендер-сервера можно не указывать (так как запросы к апи в любом случае будут сначала направлены на рендер-сервер, а затем спроксированы им на backend). При кешировании выше ноды обязательно указывать, так как в противном случае рендер-сервер не будет знать куда ему обратиться за данными. 

* **MICRO_CACHE** - включать или не включать микрокэширование на уровне рендер-сервера. По умолчанию false  


## Подключение на продакшене 

Точка входа в приложение экспортирует express-инстанс рендер-сервера. 
Это позволяет подключить фронтенд как npm-зависимость.

1) в package.json подключить репозиторий с фронтендом: 
```json
{
    "frontend": "git+ssh://FRONTEND_REPOSITORY",
}
```

где FRONTEND_REPOSITORY - репозиторий с фронтендом. 

2) подключить инстанс рендер-сервера там где его планируется использовать:
```javascript
const renderServer = require('vue-ssr-frontend');
const app = renderServer({
    useProxy: true,
    useMicroCache: false 
});

const port = process.env.PORT || 8080
app.listen(port, () => {
  console.log(`server started at localhost: ${port}`)
});
```
при включенной опции useProxy рендер-сервер будет проксировать все запросы к /api на localhost:3000. 
Можно также передать свой сервер и порт для проксирования:

```javascript
const renderServer = require('vue-ssr-frontend'');
const app = renderServer({
    useProxy: true,
    proxyTarget: 'http://localhost:5656'
});
```

или переложить проксирование на внешний front-сервер: 
```javascript
const renderServer = require('vue-ssr-frontend'');
const app = renderServer({
    useProxy: false, //рендер-сервер не проксирует запросы к апи
    useMicroCache: false 
});
```
ВАЖНО! При перекладывании задачи проксирования на внешний сервер необходимо обязательно задать переменную окружения BACKEND_PORT. 



## Отличия от сборки vue-hackernews-2.0 от Эвана 

1) универсальный webpack-конфиг позволяющий собирать как приложение с серверным рендирингом, так и обычные спа

2) универсальная клиентская точка входа, подходящая как для клиенской части приложения с серверным рендирингом, так и для обычного спа

3) наличие глобальной функции предзагрузки данных ПЕРЕД инициализацией всего приложения. Эта функция может быть экспортирована из главного хранилища /source/app/store/index.js. Как случае серверного рендеринга, так и в случае обычного спа выполняется после разрешения роутера и инициализации стора, но до вызова asyncData соответствующих компонентов. 
При SSR выполняется строго на сервере, при SPA - строго на клиенте 

4) В компоненты добавлена новая хука storeRegister. В этой хуке можно зарегистрировать модули стора. Запускается перед вызовом asyncData и решает проблему отсуствующих модулей, возникающую в vue-hackernews-2.0 при подключении модуля стора локально:

локальный модуль хранилища:
```javascript
export default function createStoreModule() {
    return {
        namespaced: true, 
        state: {
            //
        },
        mutations: {
            //
        },
        actions: {
            //некий экшен возвращающий промис
            someAction({store, commit}) {
                //
            }
        }
    }
}
```


Vue-компонент:
```html 
<script> 
    import createStoreModule from './store';

    export default {
        name: 'someComponent', 
        storeRegister({store}) {
            //выполнится после разрешения роутера, но до asyncData
            store.registerModule('moduleName', createStoreModule()); 
        },
        destroyed() {
            this.$store.unregisterModule('moduleName');
        },
        asyncData({store, route}) {
            //видит зарегистрированный модуль
            store.dispatch('moduleName/someAction');
        }
    }
</script>
```

ОЧЕНЬ ВАЖНО! ПРИ ПОДКЛЮЧЕНИИ ЛЮБЫХ МОДУЛЕЙ ХРАНИЛИЩА КАК В MODULES КОРНЕВОГО ХРАНИЛИЩА, ТАК И ЧЕРЕЗ ХУКУ STOREREGISTER НЕОБХОДИМО ОБОРАЧИВАТЬ МОДУЛЬ В ФУНКЦИЮ. ЕСЛИ ЭТОГО НЕ СДЕЛАТЬ, ПРОИЗОЙДЕТ НЕПОПРОВИМОЕ, СЛОЖНО УЛОВИМОЕ ЗАРЯЗНЕНИЕ СОСТОЯНИЯ, ПРИ КОТОРОМ ЮЗЕРУ ОТДАЕТСЯ СОСТОЯНИЕ ДРУГОГО ПОЛЬЗОВАТЕЛЯ СО ВСЕИ ЕГО ДАННЫМИ!

Стоит также обратить внимание, на то что asyncData всегда должна возвращать промис. Поэтому, в случае чего return Promise.resolve()

5) добавлена поддержка async/await в babel 

6) Файл variables.scss задает глобальные scss переменные для всего приложения. При задании в любом вью компоненте секции template c lang=scss этот файл будет автоматически импортирован в этот блок:

source/app/variables.scss:
```scss
@base-color: #f0f0f0;
//
```

vue-компонент:
<style lang="scss" scoped> 

.class-a {
    color: $base-color 
}

</style>

мы могли бы написать @import "../../variables.scss" но за нас это делает sass-resource-loader. 

7) url-loader для вставки небольших изображений инлайн-base64

8) модульный конфиг из переиспользуемых кусков (/webpack)






