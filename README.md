# SSR VueJS 42px Template

* Webpack
* Babel
* VueJS
* Vuex
* Vue-router
* Express (как роутер для рендер-сервера)
* scss/sass
* postcss (autoprefixer)
* dev-server (HMR)
* uglifyJS

VueJS шаблон для разработки и cборки приложений с серверным рендерингом или без него (обычное html/css/js SPA). 
Базируется на официальной документации VueJs по сборке [SSR-фронтенда](https://ssr.vuejs.org/) и официальном примере [сборки от Эвана](https://github.com/vuejs/vue-hackernews-2.0), коя была значительно расширена и модифицирована исходя из задач реального проекта. 

Перед исполдьзованием необходимо переименовать app.env.example в app.env (используется для задания редкоимзеняемых переменных окружения). 


## Использование

**npm run dev** - запускает dev-server с серверным рендерингом

**npm run build** - билдит серверный бандл и клиентский манифест для серверного рендеринга

**npm run build-server** - билдит серверный бандл для SSR

**npm run build-client** - билдит клиентское приложение, формирует манифест SSR 

**npm run render-server** - запускает продакшн рендер-сервер на базе express. 

**npm run dev-spa** - запускает dev-server с традиционным SPA (без SSR)

**npm run build-spa** - билдит традиционное spa (без SSR)

**npm run tests** - запуск юнит-тестов Karms + mocha 


Использование npm run build-server и npm run build-client в отдельности не имеет особого смысла в большинстве случаев. Для сборки используйте npm run build. 

## Конфигурация вебпака

Конфигурация вебпака разделена на несколько модулей:

**webpack.spa.base.config.js** -  Базовый конфиг обыкновенного SPA

**webpack.spa.config.js** - основной конфиг обыкновенного SPA

**webpack.ssr.base.config.js** - основной кофигурационный файл сборки для серверного рендеринга. 

Содержит настройки, применимые как клиентскому, так и к серверному бандлу. 

**webpack.ssr.client.config.js** - конфигурационный файл сборки клиентской части SSR-приложения

**webpack.ssr.server.config.js** - конфигурационный файл серверной части SSR-фронтенда 

Все конфигурационные файлы используют объект из модуля /config.js в корне. Этот модуль необходим для передачи конфигурационным файлам сборки вебпака проектоспецифических настроек. 

Конфигурационный файл получает переменные окружения (заданные непосредственно при запуске, а также в файле app.env) и формирует из них удобный для использования в основных конфигах вебпака объект. 

Для более глубокого понимания конфигурационных файлов, обратитесь к официальной документации VueJS по серверному рендерингу. 

## Переменные окружения 

* **NODE_ENV** - при запуске server.js определяет окружение. В production окружении поднимает экспресс сервер с SSR-рендерингом приложения, предварительно собранного в /build. В development-окружении поднимает дев-сервер с HMR. При подключении через npm server.js запускается как production вне зависимости от реальной переменной окружения 

* **PORT** - порт на котором запускается рендер-сервер (по умолчанию 8080) в девелопмент или продакшен окружении 

* **MICRO_CACHE** - включать или не включать микрокэширование на уровне рендер-сервера. По умолчанию false  

* **BACKEND_BASE_URL** * - на этот URL будет обращаться модуль API (/source/app/api). Используется в качестве baseURL в axios. В виду того, что замена этой переменной предполагается не часто, она вынесена в app.env файл в корне проекта и передается вебпак конфигу через [dotenv](https://www.npmjs.com/package/dotenv). Здесь следует писать публичный урл, по которому доступен бэкенд. На этот url будет обращаться клиент и рендер-сервер при запросе данных с API. 

* **BACKEND_URL** - Сюда будут проксироваться запросы при включенном проксировании на уровне render-server. Задается в app.env. Здесь следует писать внутренний URL, по которому доступен бэкенд на уровне рендер-сервера. 

* **PROXY_CONTEXT** - контекст для проксирования. При включенном проксировании на уровне рендер-сервера, а также всегда в дев-режиме, запросы вида PROXY_CONTEXT будет проксироваться на **BACKEND_URL**. Например, при задании PROXY_CONTEXT = /api все запросы вида /api/** то есть /api/users/, /api/users/1, /api/users/2, /api/books и т. п. Также как и BACKEND_URL задается в файле app.env в корне проекта


## Подключение на продакшене 

> Внимание! При подключении рендер-сервера через npm необходимо чтобы app.env файл находился в репозитории. Не забудьте удалить его из гитигнор в вашей деплой ветке/репозитории

Точка входа в приложение экспортирует express-инстанс рендер-сервера. 
Это позволяет подключить фронтенд как npm-зависимость.

1) в package.json подключить репозиторий с фронтендом: 
```json
{
    "vue-ssr-frontend": "git+ssh://FRONTEND_REPOSITORY",
}
```

где FRONTEND_REPOSITORY - репозиторий с фронтендом. 

2) подключить инстанс рендер-сервера там где его планируется использовать:
```javascript
const renderServer = require('vue-ssr-frontend');
const app = renderServer({
    useProxy: true,
    useMicroCache: false 
});

const port = process.env.PORT || 8080
app.listen(port, () => {
  console.log(`server started at localhost: ${port}`)
});
```
при включенной опции useProxy рендер-сервер будет проксировать все запросы к /api на localhost:3000. 
Можно также передать свой сервер и порт для проксирования. Переданный таким образом URL будет ПРИОРИТЕТНЕЕ, нежели BACKEND_URL, указанный в app.env фронтенда. 

```javascript
const renderServer = require('vue-ssr-frontend');
const app = renderServer({
    useProxy: true,
    proxyTarget: 'http://localhost:5656'
});
```

или переложить проксирование на внешний front-сервер (Nginx, Apache etc): 
```javascript
const renderServer = require('vue-ssr-frontend');
const app = renderServer({
    useProxy: false, //рендер-сервер не проксирует запросы к апи
    useMicroCache: false 
});
```

> Стоит отметить, что подключать рендер-сервер через npm имеет смысл только в том случае, ксли это удобно исходя из вашей инфраструктуры. Ничто не мешает просто поднимать рендер-сервер из папки с проектом через npm run render-server

## Отличия от сборки vue-hackernews-2.0 от Эвана 

1) универсальный webpack-конфиг позволяющий собирать как приложение с серверным рендирингом, так и обычные спа

2) универсальная клиентская точка входа, подходящая как для клиенской части приложения с серверным рендирингом, так и для обычного спа

3) наличие глобальной функции предзагрузки данных ПЕРЕД инициализацией всего приложения. Эта функция может быть экспортирована из главного хранилища /source/app/store/index.js. Как случае серверного рендеринга, так и в случае обычного спа выполняется после разрешения роутера и инициализации стора, но до вызова asyncData соответствующих компонентов. 
При SSR выполняется строго на сервере, при SPA - строго на клиенте 

4) В компоненты добавлена новая хука storeRegister. В этой хуке можно зарегистрировать модули стора. Запускается перед вызовом asyncData и решает проблему отсуствующих модулей, возникающую в vue-hackernews-2.0 при подключении модуля стора локально:

локальный модуль хранилища:
```javascript
export default function createStoreModule() {
    return {
        namespaced: true, 
        state: {
            //
        },
        mutations: {
            //
        },
        actions: {
            //некий экшен возвращающий промис
            someAction({store, commit}) {
                //
            }
        }
    }
}
```


Vue-компонент:
```html 
<script> 
    import createStoreModule from './store';

    export default {
        name: 'someComponent', 
        storeRegister({store}) {
            //выполнится после разрешения роутера, но до asyncData
            store.registerModule('moduleName', createStoreModule()); 
        },
        destroyed() {
            this.$store.unregisterModule('moduleName');
        },
        asyncData({store, route}) {
            //видит зарегистрированный модуль
            store.dispatch('moduleName/someAction');
        }
    }
</script>
```

ОЧЕНЬ ВАЖНО! ПРИ ПОДКЛЮЧЕНИИ ЛЮБЫХ МОДУЛЕЙ ХРАНИЛИЩА КАК В MODULES КОРНЕВОГО ХРАНИЛИЩА, ТАК И ЧЕРЕЗ ХУКУ STOREREGISTER НЕОБХОДИМО ОБОРАЧИВАТЬ МОДУЛЬ В ФУНКЦИЮ. ЕСЛИ ЭТОГО НЕ СДЕЛАТЬ, ПРОИЗОЙДЕТ НЕПОПРОВИМОЕ, СЛОЖНО УЛОВИМОЕ ЗАРЯЗНЕНИЕ СОСТОЯНИЯ, ПРИ КОТОРОМ ЮЗЕРУ ОТДАЕТСЯ СОСТОЯНИЕ ДРУГОГО ПОЛЬЗОВАТЕЛЯ СО ВСЕИ ЕГО ДАННЫМИ!

Стоит также обратить внимание, на то что asyncData всегда должна возвращать промис. Поэтому, в случае чего return Promise.resolve()

5) добавлена поддержка async/await в babel 

6) Файл variables.scss задает глобальные scss переменные для всего приложения. При задании в любом вью компоненте секции template c lang=scss этот файл будет автоматически импортирован в этот блок:

source/app/variables.scss:
```scss
@base-color: #f0f0f0;
//
```

vue-компонент:
```html
<style lang="scss" scoped> 

.class-a {
    color: $base-color 
}

</style>
```

мы могли бы написать @import "../../variables.scss" но за нас это делает sass-resource-loader. 

7) url-loader для вставки небольших изображений инлайн-base64

8) модульный конфиг из переиспользуемых кусков (/webpack)






